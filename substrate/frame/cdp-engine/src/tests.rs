// This file is part of Acala.

// Copyright (C) 2020-2025 Acala Foundation.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Tests for CDP Engine pallet - generated by polka.codes

use super::*;
use frame_support::{assert_err, assert_ok, traits::Hooks};
use mock::*;

#[test]
fn set_collateral_params_works() {
	new_test_ext().execute_with(|| {
		assert_ok!(CDPEngine::set_collateral_params(
			RuntimeOrigin::root(),
			Some(Ratio::from_inner(1_800_000_000_000_000_000u128)), // 1.8
			Some(Ratio::from_inner(2_500_000_000_000_000_000u128)), // 2.5
			2_000_000u64,
		));

		let params = CDPEngine::collateral_params().unwrap();
		assert_eq!(params.liquidation_ratio, Some(Ratio::from_inner(1_800_000_000_000_000_000u128)));
		assert_eq!(params.required_collateral_ratio, Some(Ratio::from_inner(2_500_000_000_000_000_000u128)));
		assert_eq!(params.maximum_total_debit_value, 2_000_000u64);
	});
}

#[test]
fn adjust_position_works() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;
		
		assert_ok!(CDPEngine::adjust_position(
			RuntimeOrigin::signed(account_id),
			1000u64, // collateral
			150u64,  // debit (should pass minimum debit value)
		));

		let position = CDPEngine::positions(account_id);
		assert_eq!(position.collateral, 1000u64);
		assert_eq!(position.debit, 150u64);
	});
}

#[test]
fn adjust_position_fails_with_insufficient_collateral_ratio() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;
		
		// Try to create a position with low collateral ratio
		assert_err!(
			CDPEngine::adjust_position(
				RuntimeOrigin::signed(account_id),
				100u64, // low collateral
				150u64, // high debit
			),
			Error::<Test>::BelowRequiredCollateralRatio
		);
	});
}

#[test]
fn emergency_shutdown_works() {
	new_test_ext().execute_with(|| {
		assert!(!CDPEngine::is_shutdown());
		
		assert_ok!(CDPEngine::emergency_shutdown(RuntimeOrigin::root()));
		
		assert!(CDPEngine::is_shutdown());
	});
}

#[test]
fn check_cdp_status_works() {
	new_test_ext().execute_with(|| {
		// Safe CDP
		let status = CDPEngine::check_cdp_status(2000u64, 1000u64);
		assert_eq!(status, CDPStatus::Safe);
		
		// Unsafe CDP
		let status = CDPEngine::check_cdp_status(100u64, 1000u64);
		assert_eq!(status, CDPStatus::Unsafe);
		
		// Zero debit should be safe
		let status = CDPEngine::check_cdp_status(100u64, 0u64);
		assert_eq!(status, CDPStatus::Safe);
	});
}

#[test]
fn liquidate_unsafe_cdp_works() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;
		
		// First create an unsafe position directly in storage
		let unsafe_position = Position {
			collateral: 100u64,
			debit: 1000u64,
		};
		Positions::<Test>::insert(account_id, unsafe_position);
		
		assert_ok!(CDPEngine::liquidate_unsafe_cdp(&account_id));
		
		// Position should be cleared
		let position = CDPEngine::positions(account_id);
		assert_eq!(position.collateral, 0u64);
		assert_eq!(position.debit, 0u64);
	});
}

#[test]
fn settle_cdp_works() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;
		
		// Enable shutdown first
		IsShutdown::<Test>::put(true);
		
		// Create a position with debit
		let position = Position {
			collateral: 1000u64,
			debit: 500u64,
		};
		Positions::<Test>::insert(account_id, position);
		
		assert_ok!(CDPEngine::settle_cdp_has_debit(&account_id));
		
		// Position should be cleared
		let position = CDPEngine::positions(account_id);
		assert_eq!(position.collateral, 0u64);
		assert_eq!(position.debit, 0u64);
	});
}

#[test]
fn on_initialize_works() {
	new_test_ext().execute_with(|| {
		// Test that on_initialize runs without errors
		let weight = CDPEngine::on_initialize(1u64);
		assert!(weight.ref_time() > 0);
		
		// Check that timestamp is updated
		let timestamp = CDPEngine::last_accumulation_secs();
		assert!(timestamp >= 0);
	});
}