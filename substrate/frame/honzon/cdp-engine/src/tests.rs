// This file is part of Acala.

// Copyright (C) 2020-2025 Acala Foundation.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Tests for CDP Engine pallet - generated by polka.codes

use super::*;
use frame_support::{assert_err, assert_ok, traits::Hooks};
use mock::*;
use pallet_loans::Pallet as Loans;

#[test]
fn set_collateral_params_works() {
	new_test_ext().execute_with(|| {
		assert_ok!(CDPEngine::set_collateral_params(
			RuntimeOrigin::root(),
			Some(Ratio::from_inner(1_800_000_000_000_000_000u128)), // 1.8
			Some(Ratio::from_inner(2_500_000_000_000_000_000u128)), // 2.5
			2_000_000u64,
		));

		let params = CDPEngine::collateral_params().unwrap();
		assert_eq!(
			params.liquidation_ratio,
			Some(Ratio::from_inner(1_800_000_000_000_000_000u128))
		);
		assert_eq!(
			params.required_collateral_ratio,
			Some(Ratio::from_inner(2_500_000_000_000_000_000u128))
		);
		assert_eq!(params.maximum_total_debit_value, 2_000_000u64);
	});
}

#[test]
fn adjust_position_works() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;
		assert_ok!(CDPEngine::adjust_position(&account_id, 1000i128, 150i128, Some(Rate::one()),));

		let position = Loans::positions(&account_id);
		assert_eq!(position.collateral, 1000u128);
		assert_eq!(position.debit, 150u128);
		assert_eq!(position.stability_fee, Rate::one());
	});
}

#[test]
fn adjust_position_fails_with_insufficient_collateral_ratio() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;

		// Try to create a position with low collateral ratio
		assert_err!(
			CDPEngine::adjust_position(
				&account_id,
				100i128, // low collateral
				150i128, // high debit
				Some(Rate::one()),
			),
			Error::<Test>::BelowRequiredCollateralRatio
		);
	});
}

#[test]
fn emergency_shutdown_works() {
	new_test_ext().execute_with(|| {
		assert!(!CDPEngine::is_shutdown());

		assert_ok!(CDPEngine::emergency_shutdown(RuntimeOrigin::root()));

		assert!(CDPEngine::is_shutdown());
	});
}

#[test]
fn check_cdp_status_works() {
	new_test_ext().execute_with(|| {
		// Safe CDP
		let status = CDPEngine::check_cdp_status(2000u128, 1000u128, Rate::one());
		assert_eq!(status, CDPStatus::Safe);

		// Unsafe CDP
		let status = CDPEngine::check_cdp_status(100u128, 1000u128, Rate::one());
		assert_eq!(status, CDPStatus::Unsafe);

		// Zero debit should be safe
		let status = CDPEngine::check_cdp_status(100u128, 0u128, Rate::one());
		assert_eq!(status, CDPStatus::Safe);
	});
}

#[test]
fn liquidate_unsafe_cdp_works() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;

		// First create an unsafe position directly in storage
		let unsafe_position =
			Position { collateral: 100u128, debit: 1000u128, stability_fee: Ratio::one() };
		pallet_loans::Positions::<Test>::insert(account_id, unsafe_position);
		pallet_loans::TotalPositions::<Test>::put(unsafe_position);
		pallet_loans::TotalDebitByStabilityFee::<Test>::insert(Rate::one(), unsafe_position.debit);

		assert_ok!(CDPEngine::liquidate_unsafe_cdp(account_id));

		// Position should be cleared
		let position = Loans::positions(&account_id);
		assert_eq!(position.collateral, 0u128);
		assert_eq!(position.debit, 0u128);
	});
}

#[test]
fn settle_cdp_works() {
	new_test_ext().execute_with(|| {
		let account_id = 1u64;

		// Enable shutdown first
		IsShutdown::<Test>::put(true);

		// Create a position with debit
		assert_ok!(Loans::update_loan(&account_id, 1000i128, 500i128, Some(Rate::one())));

		assert_ok!(CDPEngine::settle_cdp_has_debit(account_id));

		// Position should be cleared
		let position = Loans::positions(&account_id);
		assert_eq!(position.collateral, 0u128);
		assert_eq!(position.debit, 0u128);
	});
}

#[test]
fn on_initialize_works() {
	new_test_ext().execute_with(|| {
		// Test that on_initialize runs without errors
		let weight = CDPEngine::on_initialize(1u64);
		assert!(weight.ref_time() > 0);

		// Check that timestamp is updated
		let timestamp = CDPEngine::last_accumulation_secs();
		assert!(timestamp >= 0);
	});
}
