// This file is part of Acala.

// Copyright (C) 2020-2025 Acala Foundation.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! # CDP Treasury Pallet
//!
//! ## Overview
//!
//! The CDP Treasury pallet manages the surplus and debt generated by CDPs. It handles
//! excessive surplus and debt to maintain system health and stability. This pallet is
//! the sole authority for minting and burning the stable currency of the system.

#![cfg_attr(not(feature = "std"), no_std)]
#![allow(clippy::unused_unit)]
#![allow(clippy::needless_range_loop)]

use frame_support::{
	pallet_prelude::*,
	traits::{
		fungibles::{Inspect, Mutate},
		tokens::{Balance as BalanceT, Fortitude, Precision, Preservation},
	},
	transactional, PalletId,
};
use frame_system::pallet_prelude::*;
use num_traits::ops::checked::CheckedRem;
use pallet_traits::{AuctionManager, CDPTreasury, CDPTreasuryExtended, Ratio, Swap, SwapLimit};
use sp_runtime::{
	traits::{AccountIdConversion, One, Saturating, Zero},
	ArithmeticError, DispatchError, DispatchResult, FixedPointNumber,
};
use sp_std::prelude::*;

mod mock;
mod tests;
pub mod weights;

pub use module::*;
pub use weights::WeightInfo;

#[frame_support::pallet]
pub mod module {
	use super::*;

	#[pallet::config]
	pub trait Config: frame_system::Config {
		/// The origin which may update parameters and handle surplus.
		type UpdateOrigin: EnsureOrigin<Self::RuntimeOrigin>;

		/// The fungibles instance for managing assets.
		type Fungibles: Mutate<Self::AccountId, Balance = Self::Balance, AssetId = Self::CurrencyId>;

		/// The auction manager for handling surplus and debt auctions.
		type AuctionManagerHandler: AuctionManager<
			Self::AccountId,
			Balance = Self::Balance,
			CurrencyId = Self::CurrencyId,
		>;

		/// The balance type for amounts.
		type Balance: BalanceT;

		/// The currency ID type.
		type CurrencyId: Parameter + Member + Copy + MaybeSerializeDeserialize + Ord + MaxEncodedLen;

		/// The maximum number of auctions to create for selling collateral.
		#[pallet::constant]
		type MaxAuctionsCount: Get<u32>;

		/// The account ID of the treasury.
		#[pallet::constant]
		type TreasuryAccount: Get<Self::AccountId>;

		/// The CDP treasury's pallet ID, used for deriving its account ID.
		#[pallet::constant]
		type PalletId: Get<PalletId>;

		/// Weight information for the extrinsics in this pallet.
		type WeightInfo: WeightInfo;

		/// The currency ID of the stable currency.
		type GetStableCurrencyId: Get<Self::CurrencyId>;

		/// The currency ID of the base currency.
		type GetBaseCurrencyId: Get<Self::CurrencyId>;

		/// The swap instance for trading currencies.
		type Swap: Swap<Self::AccountId, Self::Balance, Self::CurrencyId>;
	}

	#[pallet::error]
	pub enum Error<T> {
		/// The collateral amount of CDP treasury is not enough
		CollateralNotEnough,
		/// The surplus pool of CDP treasury is not enough
		SurplusPoolNotEnough,
		/// The debit pool of CDP treasury is not enough
		DebitPoolNotEnough,
		/// Cannot use collateral to swap stable
		CannotSwap,
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub fn deposit_event)]
	pub enum Event<T: Config> {
		/// Expected collateral auction size updated.
		ExpectedCollateralAuctionSizeUpdated {
			/// The new expected size of each collateral auction.
			new_size: T::Balance,
		},
		/// Debit offset buffer updated.
		DebitOffsetBufferUpdated {
			/// The new buffer amount for the debit pool.
			amount: T::Balance,
		},
	}

	/// The expected size of each collateral auction.
	#[pallet::storage]
	#[pallet::getter(fn expected_collateral_auction_size)]
	pub type ExpectedCollateralAuctionSize<T: Config> = StorageValue<_, T::Balance, ValueQuery>;

	/// The total amount of system debt.
	#[pallet::storage]
	#[pallet::getter(fn debit_pool)]
	pub type DebitPool<T: Config> = StorageValue<_, T::Balance, ValueQuery>;

	/// The buffer amount of the debit pool that will not be offset by the surplus pool.
	#[pallet::storage]
	#[pallet::getter(fn debit_offset_buffer)]
	pub type DebitOffsetBuffer<T: Config> = StorageValue<_, T::Balance, ValueQuery>;

	/// Genesis configuration for the cdp-treasury pallet.
	#[pallet::genesis_config]
	#[derive(frame_support::DefaultNoBound)]
	pub struct GenesisConfig<T: Config> {
		/// The expected size of each collateral auction.
		pub expected_collateral_auction_size: T::Balance,
		pub _phantom: sp_std::marker::PhantomData<T>,
	}

	#[pallet::genesis_build]
	impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
		fn build(&self) {
			ExpectedCollateralAuctionSize::<T>::put(self.expected_collateral_auction_size);
		}
	}

	/// The cdp-treasury pallet.
	#[pallet::pallet]
	pub struct Pallet<T>(_);

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
		/// On finalize, offset the surplus and debit pools.
		fn on_finalize(_now: BlockNumberFor<T>) {
			Self::offset_surplus_and_debit();
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		/// Extracts surplus to the treasury.
		///
		/// The dispatch origin of this call must be `UpdateOrigin`.
		///
		/// - `amount`: The amount of surplus to extract.
		#[pallet::call_index(0)]
		#[pallet::weight(T::WeightInfo::extract_surplus_to_treasury())]
		pub fn extract_surplus_to_treasury(
			origin: OriginFor<T>,
			#[pallet::compact] amount: T::Balance,
		) -> DispatchResult {
			T::UpdateOrigin::ensure_origin(origin)?;
			T::Fungibles::transfer(
				T::GetStableCurrencyId::get(),
				&Self::account_id(),
				&T::TreasuryAccount::get(),
				amount,
				Preservation::Expendable,
			)?;
			Ok(())
		}

		/// Auction the collateral not occupied by the auction.
		///
		/// The dispatch origin of this call must be `UpdateOrigin`.
		///
		/// - `amount`: collateral amount
		/// - `target`: target amount
		/// - `split`: split collateral to multiple auction according to the config size
		#[pallet::call_index(1)]
		#[pallet::weight(
			if *split {
				T::WeightInfo::auction_collateral(T::MaxAuctionsCount::get())
			} else {
				T::WeightInfo::auction_collateral(1)
			}
		)]
		pub fn auction_collateral(
			origin: OriginFor<T>,
			#[pallet::compact] amount: T::Balance,
			#[pallet::compact] target: T::Balance,
			split: bool,
		) -> DispatchResultWithPostInfo {
			T::UpdateOrigin::ensure_origin(origin)?;
			let created_auctions =
				<Self as CDPTreasuryExtended<T::AccountId>>::create_collateral_auctions(
					amount,
					target,
					Self::account_id(),
					split,
				)?;
			Ok(Some(T::WeightInfo::auction_collateral(created_auctions)).into())
		}

		/// Updates the expected size of each collateral auction.
		///
		/// The dispatch origin of this call must be `UpdateOrigin`.
		///
		/// - `size`: The expected size of each collateral auction.
		#[pallet::call_index(2)]
		#[pallet::weight((T::WeightInfo::set_expected_collateral_auction_size(), DispatchClass::Operational))]
		pub fn set_expected_collateral_auction_size(
			origin: OriginFor<T>,
			#[pallet::compact] size: T::Balance,
		) -> DispatchResult {
			T::UpdateOrigin::ensure_origin(origin)?;
			ExpectedCollateralAuctionSize::<T>::put(size);
			Self::deposit_event(Event::ExpectedCollateralAuctionSizeUpdated { new_size: size });
			Ok(())
		}

		/// Updates the debit offset buffer.
		///
		/// The dispatch origin of this call must be `UpdateOrigin`.
		///
		/// - `amount`: The new buffer amount for the debit pool.
		#[pallet::call_index(3)]
		#[pallet::weight((T::WeightInfo::set_expected_collateral_auction_size(), DispatchClass::Operational))]
		pub fn set_debit_offset_buffer(
			origin: OriginFor<T>,
			#[pallet::compact] amount: T::Balance,
		) -> DispatchResult {
			T::UpdateOrigin::ensure_origin(origin)?;
			DebitOffsetBuffer::<T>::mutate(|v| {
				if *v != amount {
					*v = amount;
					Self::deposit_event(Event::DebitOffsetBufferUpdated { amount });
				}
			});
			Ok(())
		}
	}
}

impl<T: Config> Pallet<T> {
	/// The account ID of the cdp-treasury pallet.
	pub fn account_id() -> T::AccountId {
		T::PalletId::get().into_account_truncating()
	}

	/// The total surplus of the system.
	pub fn surplus_pool() -> T::Balance {
		T::Fungibles::balance(T::GetStableCurrencyId::get(), &Self::account_id())
	}

	/// The total collateral amount of the cdp-treasury pallet.
	pub fn total_collaterals() -> T::Balance {
		T::Fungibles::balance(T::GetBaseCurrencyId::get(), &Self::account_id())
	}

	/// The collateral amount not in an auction.
	pub fn total_collaterals_not_in_auction() -> T::Balance {
		Self::total_collaterals().saturating_sub(
			T::AuctionManagerHandler::get_total_collateral_in_auction(T::GetBaseCurrencyId::get()),
		)
	}

	/// Offsets the surplus and debit pools.
	fn offset_surplus_and_debit() {
		// The part of the debit pool that exceeds the debit offset buffer can be offset by the
		// surplus
		let offset_amount = sp_std::cmp::min(
			Self::debit_pool().saturating_sub(Self::debit_offset_buffer()),
			Self::surplus_pool(),
		);

		// Burn the amount that is equal to offset amount of stable currency.
		if !offset_amount.is_zero() {
			let res = Self::burn_debit(&Self::account_id(), offset_amount);
			match res {
				Ok(_) => {
					DebitPool::<T>::mutate(|debit| {
						*debit = debit
							.checked_sub(&offset_amount)
							.expect("offset = min(debit, surplus); qed")
					});
				},
				Err(e) => {
					log::warn!(
						target: "cdp-treasury",
						"get_swap_supply_amount: Attempt to burn surplus {:?} failed: {:?}, this is unexpected but should be safe",
						offset_amount, e
					);
				},
			}
		}
	}
}

impl<T: Config> CDPTreasury<T::AccountId> for Pallet<T> {
	type Balance = T::Balance;
	type CurrencyId = T::CurrencyId;

	/// The account ID of the cdp-treasury pallet.
	fn account_id() -> T::AccountId {
		Self::account_id()
	}

	/// Pays a surplus.
	fn pay_surplus(amount: Self::Balance) -> DispatchResult {
		T::Fungibles::mint_into(T::GetStableCurrencyId::get(), &Self::account_id(), amount)
			.map(|_| ())
	}

	/// Refunds a surplus.
	fn refund_surplus(amount: Self::Balance) -> DispatchResult {
		T::Fungibles::burn_from(
			T::GetStableCurrencyId::get(),
			&Self::account_id(),
			amount,
			Preservation::Expendable,
			Precision::Exact,
			Fortitude::Polite,
		)
		.map(|_| ())
	}

	/// Gets the surplus pool.
	fn get_surplus_pool() -> Self::Balance {
		Self::surplus_pool()
	}

	/// Gets the debit pool.
	fn get_debit_pool() -> Self::Balance {
		Self::debit_pool()
	}

	/// Gets the total collaterals.
	fn get_total_collaterals() -> Self::Balance {
		Self::total_collaterals()
	}

	/// Deposits collateral.
	fn deposit_collateral(_from: &T::AccountId, _amount: Self::Balance) -> DispatchResult {
		T::Fungibles::transfer(
			T::GetBaseCurrencyId::get(),
			_from,
			&Self::account_id(),
			_amount,
			Preservation::Expendable,
		)
		.map(|_| ())
	}

	/// Withdraws collateral.
	fn withdraw_collateral(_to: &T::AccountId, _amount: Self::Balance) -> DispatchResult {
		T::Fungibles::transfer(
			T::GetBaseCurrencyId::get(),
			&Self::account_id(),
			_to,
			_amount,
			Preservation::Expendable,
		)
		.map(|_| ())
	}

	/// Gets the debit proportion.
	fn get_debit_proportion(amount: Self::Balance) -> Ratio {
		let stable_total_supply = T::Fungibles::total_issuance(T::GetStableCurrencyId::get());
		Ratio::checked_from_rational(amount, stable_total_supply).unwrap_or_default()
	}

	/// Handles a system debit.
	fn on_system_debit(amount: Self::Balance) -> DispatchResult {
		DebitPool::<T>::try_mutate(|debit_pool| -> DispatchResult {
			*debit_pool = debit_pool.checked_add(&amount).ok_or(ArithmeticError::Overflow)?;
			Ok(())
		})
	}

	/// Handles a system surplus.
	fn on_system_surplus(amount: Self::Balance) -> DispatchResult {
		Self::issue_debit(&Self::account_id(), amount, true)
	}

	/// Issues a debit. This should be the only function in the system that issues stable coin.
	fn issue_debit(who: &T::AccountId, debit: Self::Balance, backed: bool) -> DispatchResult {
		// increase system debit if the debit is unbacked
		if !backed {
			Self::on_system_debit(debit)?;
		}
		T::Fungibles::mint_into(T::GetStableCurrencyId::get(), who, debit)?;

		Ok(())
	}

	/// Burns a debit. This should be the only function in the system that burns stable coin.
	fn burn_debit(who: &T::AccountId, debit: Self::Balance) -> DispatchResult {
		T::Fungibles::burn_from(
			T::GetStableCurrencyId::get(),
			who,
			debit,
			Preservation::Expendable,
			Precision::Exact,
			Fortitude::Polite,
		)
		.map(|_| ())
	}

	/// Deposits a surplus.
	fn deposit_surplus(from: &T::AccountId, surplus: Self::Balance) -> DispatchResult {
		T::Fungibles::transfer(
			T::GetStableCurrencyId::get(),
			from,
			&Self::account_id(),
			surplus,
			Preservation::Preserve,
		)
		.map(|_| ())
	}

	/// Withdraws a surplus.
	fn withdraw_surplus(to: &T::AccountId, surplus: Self::Balance) -> DispatchResult {
		T::Fungibles::transfer(
			T::GetStableCurrencyId::get(),
			&Self::account_id(),
			to,
			surplus,
			Preservation::Expendable,
		)
		.map(|_| ())
	}
}

impl<T: Config> CDPTreasuryExtended<T::AccountId> for Pallet<T> {
	/// Swaps collateral to stable currency.
	#[transactional]
	fn swap_collateral_to_stable(
		limit: SwapLimit<T::Balance>,
		collateral_in_auction: bool,
	) -> sp_std::result::Result<(T::Balance, T::Balance), DispatchError> {
		let supply_limit = match limit {
			SwapLimit::ExactSupply(supply_amount, _) => supply_amount,
			SwapLimit::ExactTarget(max_supply_amount, _) => max_supply_amount,
		};

		if collateral_in_auction {
			ensure!(
				Self::total_collaterals() >= supply_limit &&
					T::AuctionManagerHandler::get_total_collateral_in_auction(
						T::GetBaseCurrencyId::get()
					) >= supply_limit,
				Error::<T>::CollateralNotEnough,
			);
		} else {
			ensure!(
				Self::total_collaterals_not_in_auction() >= supply_limit,
				Error::<T>::CollateralNotEnough,
			);
		}

		T::Swap::swap(
			&Self::account_id(),
			T::GetBaseCurrencyId::get(),
			T::GetStableCurrencyId::get(),
			limit,
		)
	}

	/// Creates collateral auctions.
	fn create_collateral_auctions(
		amount: T::Balance,
		target: T::Balance,
		refund_receiver: T::AccountId,
		split: bool,
	) -> Result<u32, DispatchError> {
		ensure!(
			Self::total_collaterals_not_in_auction() >= amount,
			Error::<T>::CollateralNotEnough,
		);

		let mut unhandled_collateral_amount = amount;
		let mut unhandled_target = target;
		let expected_collateral_auction_size = Self::expected_collateral_auction_size();
		let max_auctions_count: T::Balance = T::MaxAuctionsCount::get().into();
		let lots_count = if !split ||
			max_auctions_count.is_zero() ||
			expected_collateral_auction_size.is_zero() ||
			amount <= expected_collateral_auction_size
		{
			One::one()
		} else {
			let mut count = amount
				.checked_div(&expected_collateral_auction_size)
				.expect("collateral auction maximum size is not zero; qed");

			let remainder = amount
				.checked_rem(&expected_collateral_auction_size)
				.expect("collateral auction maximum size is not zero; qed");
			if !remainder.is_zero() {
				count = count.saturating_add(One::one());
			}
			sp_std::cmp::min(count, max_auctions_count)
		};
		let average_amount_per_lot =
			amount.checked_div(&lots_count).expect("lots count is at least 1; qed");
		let average_target_per_lot =
			target.checked_div(&lots_count).expect("lots count is at least 1; qed");
		let mut created_lots: T::Balance = Zero::zero();

		while !unhandled_collateral_amount.is_zero() {
			created_lots = created_lots.saturating_add(One::one());
			let (lot_collateral_amount, lot_target) = if created_lots == lots_count {
				// the last lot may be have some remnant than average
				(unhandled_collateral_amount, unhandled_target)
			} else {
				(average_amount_per_lot, average_target_per_lot)
			};

			T::AuctionManagerHandler::new_collateral_auction(
				&refund_receiver,
				T::GetBaseCurrencyId::get(),
				lot_collateral_amount,
				lot_target,
			)?;

			unhandled_collateral_amount =
				unhandled_collateral_amount.saturating_sub(lot_collateral_amount);
			unhandled_target = unhandled_target.saturating_sub(lot_target);
		}
		let created_auctions: u32 =
			created_lots.try_into().map_err(|_| ArithmeticError::Overflow)?;
		Ok(created_auctions)
	}

	/// The maximum number of auctions.
	fn max_auction() -> u32 {
		T::MaxAuctionsCount::get()
	}
}

/// Initializes the debit offset buffer.
pub struct InitializeDebitOffsetBuffer<T, GetBufferSize>(
	sp_std::marker::PhantomData<T>,
	sp_std::marker::PhantomData<GetBufferSize>,
);
impl<T: Config, GetBufferSize: Get<T::Balance>> frame_support::traits::OnRuntimeUpgrade
	for InitializeDebitOffsetBuffer<T, GetBufferSize>
{
	fn on_runtime_upgrade() -> Weight {
		let amount = GetBufferSize::get();
		DebitOffsetBuffer::<T>::mutate(|v| {
			if *v != amount {
				*v = amount;
				Pallet::<T>::deposit_event(Event::DebitOffsetBufferUpdated { amount });
			}
		});

		Weight::from_parts(0, 0)
	}
}
