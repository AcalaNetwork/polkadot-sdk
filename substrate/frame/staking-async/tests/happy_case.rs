// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

use anyhow::anyhow;
use subxt::{dynamic, dynamic::Value, ext::scale_value::Composite, OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;
use zombienet_sdk::{NetworkConfig, NetworkConfigBuilder};

#[subxt::subxt(runtime_metadata_path = "tests/metadata/polkadot-metadata-stripped.scale")]
pub mod polkadot {}

#[subxt::subxt(runtime_metadata_path = "tests/metadata/ah-metadata-stripped.scale")]
pub mod assethub {}

// Events generated by rc_client. Event here doesn't necessary mean 'event in the substrate
// context'. It can be anything representing a point of interest for the tests.
enum RcClientEvent {
	SessionReportReceived { activation_time_stamp: Option<u64> },
	PagedElectionProceeded { page_idx: u32, page_content: Result<u32, ()> },
}

// Events generated by ah_client. See [`RcEvents`] for what an event means in this context.
enum AhClientEvent {
	NewValidatorSetCount(u32),
}

enum TestState {
	// When AH is spawned and AhClient is activated on RC at least a single session change should
	// happen before an election is triggered.
	WaitingForInitialSessionChange,
	// Wait for an election to complete. We get into this state after the first session change and
	// move on when we receive a page containing `Ok(0)` as a result.
	WaitingForElectionResult,
	// The validator set should be delivered to RC
	WaitForNewValidatorSetCount,
	// AH should receive a session report with an activation timestamp
	WaitForSessionReportWithActivationTimestamp { elapsed_sessions: usize },
}

impl TestState {
	pub fn new() -> Self {
		Self::WaitingForInitialSessionChange
	}

	pub fn on_ah_client_event(&mut self, event: AhClientEvent) {
		match event {
			AhClientEvent::NewValidatorSetCount(new_validator_set_count) => {
				self.handle_new_validator_set_count(new_validator_set_count);
			},
		}
	}

	pub fn on_rc_client_event(
		&mut self,
		event: RcClientEvent,
		end_test: &mut Option<tokio::sync::oneshot::Sender<()>>,
	) {
		match event {
			RcClientEvent::SessionReportReceived { activation_time_stamp } => {
				self.handle_ah_session_report_received(activation_time_stamp, end_test);
			},
			RcClientEvent::PagedElectionProceeded { page_idx, page_content } => {
				self.handle_ah_paged_election_proceeded(page_idx, page_content);
			},
		}
	}

	fn handle_ah_session_report_received(
		&mut self,
		activation_time_stamp: Option<u64>,
		end_test: &mut Option<tokio::sync::oneshot::Sender<()>>,
	) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				log::info!("One session change after activating AH client");
				*self = TestState::WaitingForElectionResult;
			},
			TestState::WaitingForElectionResult => {
				// ignore
			},
			TestState::WaitForNewValidatorSetCount => {
				// ignore
			},
			TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions } => {
				if activation_time_stamp.is_some() {
					log::info!(
						"Got session report with activation timestamp: {:?}",
						activation_time_stamp
					);
					// All done. Terminate the test.
					end_test.take().unwrap().send(()).unwrap();
					return
				}
				*elapsed_sessions += 1;

				if *elapsed_sessions > 6 {
					assert!(
						activation_time_stamp.is_some(),
						"Expected activation time stamp within 6 sessions"
					);
				}
			},
		}
	}

	fn handle_ah_paged_election_proceeded(&mut self, page_idx: u32, page_content: Result<u32, ()>) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				assert!(false, "PagedElectionProceeded before the first session change?");
			},
			TestState::WaitingForElectionResult => {
				log::info!(
					"Paged election proceeded: page_idx: {}, page_content: {:?}",
					page_idx,
					page_content
				);

				// we can be smarter here and avoid the magic numbers
				if page_idx == 7 {
					assert!(page_content.is_ok(), "Expected Ok");
					assert!(page_content.unwrap() == 500, "Expected 500");
				} else if page_idx == 6 {
					assert!(page_content.is_ok(), "Expected Ok");
					assert!(page_content.unwrap() == 0, "Expected 0");

					// at this point it's safe to assume that the election is complete
					// we will get more `PagedElectionProceeded` with `Err` but we'll just ignore
					// them
					*self = TestState::WaitForNewValidatorSetCount;
					log::info!("Election complete, waiting for validator set on RC");
				} else {
					assert!(page_content.is_err(), "Expected Err for page {}", page_idx);
				}
			},
			TestState::WaitForNewValidatorSetCount => {
				// as per the comment above - ignore these
			},
			TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions: _ } => {
				// ignore
			},
		}
	}

	fn handle_new_validator_set_count(&mut self, new_validator_set_count: u32) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				assert!(false, "New validator set count before the first session change?");
			},
			TestState::WaitingForElectionResult => {
				assert!(false, "New validator set count before the election is complete?");
			},
			TestState::WaitForNewValidatorSetCount => {
				assert!(new_validator_set_count == 500, "Expected a validator set count of 500");
				log::info!("Got NewValidatorSetCount on RC");
				*self =
					TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions: 0 };
			},
			TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions: _ } => {
				// ignore
			},
		}
	}
}

#[ignore = "Intended for local runs only because it requires manual steps and takes quite a lot of time to execute"]
#[tokio::test(flavor = "multi_thread")]
async fn happy_case() -> Result<(), anyhow::Error> {
	let _ = env_logger::try_init_from_env(
		env_logger::Env::default().filter_or(env_logger::DEFAULT_FILTER_ENV, "info"),
	);

	let config = build_network_config().await?;

	let spawn_fn = zombienet_sdk::environment::get_spawn_fn();
	let network = spawn_fn(config).await?;

	log::info!("Spawned");

	let rc_node = network.get_node("alice")?;
	let ah_next_node = network.get_node("charlie")?;

	let rc_client: OnlineClient<PolkadotConfig> = rc_node.wait_client().await?;
	let ah_next_client: OnlineClient<PolkadotConfig> = ah_next_node.wait_client().await?;

	let mut test_state = TestState::new();

	log::info!("Set validator count to 500");
	// Validator count is set in the chainspec but for a still unknown reason the value doesn't get
	// set in the storage item. Once this mystery is solved this call should be removed.
	set_validator_count(&ah_next_client, 500).await?;

	log::info!("Activate AH Client");
	activate_ah_client(&rc_client).await?;

	let mut rc_blocks_sub = rc_client.blocks().subscribe_finalized().await?;
	let mut ah_blocks_sub = ah_next_client.blocks().subscribe_finalized().await?;
	let (tx, rx) = tokio::sync::oneshot::channel::<()>();
	let mut rx = rx;
	let mut tx = Some(tx);

	loop {
		tokio::select! {
			rc_block = rc_blocks_sub.next() => {
				if let Some(block) = rc_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;
						if event.pallet_name() == "StakingNextAhClient" {
							match event.variant_name() {
								"ValidatorSetReceived" => {
									let ev = event.as_event::<polkadot::staking_next_ah_client::events::ValidatorSetReceived>()?.expect("ValidatorSetReceived event should be parsed");
									test_state.on_ah_client_event(AhClientEvent::NewValidatorSetCount(ev.new_validator_set_count));
								},
								_ => {
									log::debug!(
										"ON RC: block: {}; pallet: StakingNextAhClient;  Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						}
					}
				}
			}
			ah_block = ah_blocks_sub.next() => {
				if let Some(block) = ah_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;

						if event.pallet_name() == "StakingNextRcClient" {
							match event.variant_name() {
								"SessionReportReceived" => {
									let ev = event.as_event::<assethub::staking_next_rc_client::events::SessionReportReceived>()?.expect("SessionReportReceived event should be parsed");
									test_state.on_rc_client_event(RcClientEvent::SessionReportReceived { activation_time_stamp: ev.activation_timestamp.map(|timestamp| timestamp.0) }, &mut tx);
								},
								_ => {
									log::debug!(
										"ON AH: block: {} StakingNextRcClient Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}

						} else if event.pallet_name() == "Staking" {
							match event.variant_name() {
								"PagedElectionProceeded" => {
									log::debug!(
										"ON AH: block: {} Staking PagedElectionProceeded Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
									let ev = event.as_event::<assethub::staking::events::PagedElectionProceeded>()?.expect("PagedElectionProceeded event should be parsed");
									test_state.on_rc_client_event(RcClientEvent::PagedElectionProceeded{ page_idx: ev.page, page_content: ev.result.map_err(|_| ())}, &mut tx);
								},
								_ => {
									log::debug!(
										"ON AH: block: {} Staking Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						} else if event.pallet_name() == "StakingNextAhClient" {
							assert!(false, "StakingNextAhClient event on AH client");
						}
						else {
							log::debug!("block: {} Event for pallet: {:?}; variant: {:?}; fields: {:?}", block.number(), event.pallet_name(), event.variant_name(), event.field_values()?);
						}
					}
				}
			}
			_ = &mut rx => {
				log::info!("Test finished");
				break
			}
		}
	}

	Ok(())
}

/// Sets `ValidatorCount` in staking pallet to `validator_count`.
async fn set_validator_count(
	ah_client: &OnlineClient<PolkadotConfig>,
	validator_count: u32,
) -> Result<(), anyhow::Error> {
	let set_validator_count = dynamic::tx("Staking", "set_validator_count", vec![validator_count]);
	let sudo = dynamic::tx("Sudo", "sudo", vec![set_validator_count.into_value()]);
	let alice = dev::alice();

	ah_client
		.tx()
		.sign_and_submit_then_watch_default(&sudo, &alice)
		.await?
		.wait_for_finalized_success()
		.await?;
	Ok(())
}

/// Sets `Mode` in `StakingNextAhClient` pallet to `Active`.
async fn activate_ah_client(rc_client: &OnlineClient<PolkadotConfig>) -> Result<(), anyhow::Error> {
	let mode_value = Value::variant("Active", Composite::unnamed(vec![]));
	let set_validator_count = dynamic::tx("StakingNextAhClient", "set_mode", vec![mode_value]);
	let sudo = dynamic::tx("Sudo", "sudo", vec![set_validator_count.into_value()]);
	let alice = dev::alice();

	rc_client
		.tx()
		.sign_and_submit_then_watch_default(&sudo, &alice)
		.await?
		.wait_for_finalized_success()
		.await?;
	Ok(())
}

/// Builds a dummy RC and AH networks with the test runtimes from pallet-staking-async
async fn build_network_config() -> Result<NetworkConfig, anyhow::Error> {
	let images = zombienet_sdk::environment::get_images_from_env();
	log::info!("Using images: {images:?}");
	NetworkConfigBuilder::new()
		.with_relaychain(|r| {
			r
				.with_chain("custom")
				.with_chain_spec_path("rc.json") // TODO: how to autogenerate this?
				.with_default_command("polkadot")
				.with_default_image(images.polkadot.as_str())
				.with_default_args(vec![("-lparachain=trace").into()])
				.with_default_resources(|resources| {
					resources.with_request_cpu(2).with_request_memory("2G")
				})
				.with_node(|n| n.with_name("alice"))
				.with_node(|n| n.with_name("bob"))
		})
		.with_parachain(|p| {
			p.with_id(1100)
			.with_chain_spec_path("parachain.json") // TODO: how to autogenerate this?
				.with_default_command("polkadot-parachain")
				.with_default_image(images.cumulus.as_str())
				.with_default_args(vec![
					("-lruntime::system=debug,runtime::multiblock-election=debug,runtime::staking=debug,runtime::staking::rc-client=trace").into(),
				])
				.with_collator(|n| n.with_name("charlie"))
		})
		.with_global_settings(|global_settings| match std::env::var("ZOMBIENET_SDK_BASE_DIR") {
			Ok(val) => global_settings.with_base_dir(val),
			_ => global_settings,
		})
		.build()
		.map_err(|e| {
			let errs = e.into_iter().map(|e| e.to_string()).collect::<Vec<_>>().join(" ");
			anyhow!("config errs: {errs}")
		})
}
