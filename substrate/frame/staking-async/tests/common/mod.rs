// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

use anyhow::anyhow;
use subxt::{
	dynamic,
	dynamic::Value,
	ext::scale_value::{At, Composite, ValueDef},
	OnlineClient, PolkadotConfig,
};
use subxt_signer::sr25519::dev;
use zombienet_sdk::{NetworkConfig, NetworkConfigBuilder};

// Events generated by rc_client. Event here doesn't necessary mean 'event in the substrate
// context'. It can be anything representing a point of interest for the tests.
pub enum RcClientEvent {
	SessionReportReceived { activation_time_stamp: Option<u64> },
	PagedElectionProceeded { page_idx: u32, page_content: Result<u32, ()> },
}

// Events generated by ah_client. See [`RcEvents`] for what an event means in this context.
pub enum AhClientEvent {
	NewValidatorSetCount(u32),
}

// Used to handle events generated from the zombienet setup.
pub trait TestEventHandler {
	fn on_ah_client_event(
		&mut self,
		event: AhClientEvent,
		end_test: &mut Option<tokio::sync::oneshot::Sender<()>>,
	);
	fn on_rc_client_event(
		&mut self,
		event: RcClientEvent,
		end_test: &mut Option<tokio::sync::oneshot::Sender<()>>,
	);
}

/// Listens for events from the network and delivers them to the `TestEventHandler`
pub async fn event_loop(
	rc_client: &OnlineClient<PolkadotConfig>,
	ah_next_client: &OnlineClient<PolkadotConfig>,
	event_handler: &mut impl TestEventHandler,
) -> Result<(), anyhow::Error> {
	let mut rc_blocks_sub = rc_client.blocks().subscribe_finalized().await?;
	let mut ah_blocks_sub = ah_next_client.blocks().subscribe_finalized().await?;
	let (tx, rx) = tokio::sync::oneshot::channel::<()>();
	let mut test_finished = rx;
	let mut notify_test_finished = Some(tx);

	loop {
		tokio::select! {
			rc_block = rc_blocks_sub.next() => {
				if let Some(block) = rc_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;
						if event.pallet_name() == "StakingNextAhClient" {
							match event.variant_name() {
								"ValidatorSetReceived" => {
									let ev = parse_new_validator_set_count(event.field_values()?).expect("ValidatorSetReceived event should be parsed");
									event_handler.on_ah_client_event(ev, &mut notify_test_finished);
								},
								_ => {
									log::debug!(
										"ON RC: block: {}; pallet: StakingNextAhClient;  Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						}
					}
				}
			}
			ah_block = ah_blocks_sub.next() => {
				if let Some(block) = ah_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;

						if event.pallet_name() == "StakingNextRcClient" {
							match event.variant_name() {
								"SessionReportReceived" => {
									let fields = event.field_values()?;
									let ev = parse_session_report_received(fields).expect("SessionReportReceived event should be parsed");
									event_handler.on_rc_client_event(ev, &mut notify_test_finished);
								},
								_ => {
									log::debug!(
										"ON AH: block: {} StakingNextRcClient Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}

						} else if event.pallet_name() == "Staking" {
							match event.variant_name() {
								"PagedElectionProceeded" => {
									log::debug!(
										"ON AH: block: {} Staking PagedElectionProceeded Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
									let ev = parse_paged_election_proceeded(event.field_values()?).expect("PagedElectionProceeded event should be parsed");
									event_handler.on_rc_client_event(ev, &mut notify_test_finished);
								},
								_ => {
									log::debug!(
										"ON AH: block: {} Staking Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						} else if event.pallet_name() == "StakingNextAhClient" {
							assert!(false, "StakingNextAhClient event on AH client");
						}
						else {
							log::debug!("block: {} Event for pallet: {:?}; variant: {:?}; fields: {:?}", block.number(), event.pallet_name(), event.variant_name(), event.field_values()?);
						}
					}
				}
			}
			_ = &mut test_finished => {
				log::info!("Test finished");
				break
			}
		}
	}

	Ok(())
}

fn parse_paged_election_proceeded(fields: Composite<u32>) -> Option<RcClientEvent> {
	let page_idx: u32 = fields.at("page").unwrap().as_u128().unwrap().try_into().unwrap();
	let result = fields.at("result").unwrap();

	let ValueDef::Variant(result) = &result.value else {
		panic!("Expected result field to be a variant");
	};

	if result.name == "Err" {
		return Some(RcClientEvent::PagedElectionProceeded { page_idx, page_content: Err(()) })
	}

	assert!(result.name == "Ok", "Expected Ok");

	Some(RcClientEvent::PagedElectionProceeded {
		page_idx,
		page_content: Ok(result.at(0).unwrap().as_u128().unwrap().try_into().unwrap()),
	})
}

fn parse_new_validator_set_count(fields: Composite<u32>) -> Option<AhClientEvent> {
	let new_validator_set_count: u32 = fields
		.at("new_validator_set_count")
		.unwrap()
		.as_u128()
		.unwrap()
		.try_into()
		.unwrap();
	return Some(AhClientEvent::NewValidatorSetCount(new_validator_set_count))
}

fn parse_session_report_received(fields: Composite<u32>) -> Option<RcClientEvent> {
	let activation_timestamp_variant = fields.at("activation_timestamp").unwrap();

	let ValueDef::Variant(activation_timestamp_variant) = &activation_timestamp_variant.value
	else {
		panic!("Expected activation_timestamp field to be a variant");
	};

	if activation_timestamp_variant.name == "None" {
		return Some(RcClientEvent::SessionReportReceived { activation_time_stamp: None })
	}

	assert!(activation_timestamp_variant.name == "Some", "Expected Some");

	// Here we are parsing:
	//
	// Variant { name: "Some", values: Unnamed([Value { value: Composite(Unnamed([Value { value:
	// Primitive(U128(1745574174001)), context: 12 }, Value { value: Primitive(U128(1)), context: 4
	// }])), context: 204 }]) }
	let activation_time_stamp = activation_timestamp_variant
		.at(0) // the value of `Some`
		.unwrap()
		.at(0) // the 1st value in the composite
		.unwrap()
		.as_u128()
		.unwrap()
		.try_into()
		.unwrap();

	Some(RcClientEvent::SessionReportReceived {
		activation_time_stamp: Some(activation_time_stamp),
	})
}

/// Builds a dummy RC and AH networks with the test runtimes from pallet-staking-async
pub async fn build_network_config() -> Result<NetworkConfig, anyhow::Error> {
	let images = zombienet_sdk::environment::get_images_from_env();
	log::info!("Using images: {images:?}");
	NetworkConfigBuilder::new()
		.with_relaychain(|r| {
			r
				.with_chain("custom")
				.with_chain_spec_path("rc.json") // TODO: how to autogenerate this?
				.with_default_command("polkadot")
				.with_default_image(images.polkadot.as_str())
				.with_default_args(vec![("-lparachain=trace").into()])
				.with_default_resources(|resources| {
					resources.with_request_cpu(2).with_request_memory("2G")
				})
				.with_node(|n| n.with_name("alice"))
				.with_node(|n| n.with_name("bob"))
		})
		.with_parachain(|p| {
			p.with_id(1100)
			.with_chain_spec_path("parachain.json") // TODO: how to autogenerate this?
				.with_default_command("polkadot-parachain")
				.with_default_image(images.cumulus.as_str())
				.with_default_args(vec![
					("-lruntime::system=debug,runtime::multiblock-election=debug,runtime::staking=debug,runtime::staking::rc-client=trace").into(),
				])
				.with_collator(|n| n.with_name("charlie"))
		})
		.with_global_settings(|global_settings| match std::env::var("ZOMBIENET_SDK_BASE_DIR") {
			Ok(val) => global_settings.with_base_dir(val),
			_ => global_settings,
		})
		.build()
		.map_err(|e| {
			let errs = e.into_iter().map(|e| e.to_string()).collect::<Vec<_>>().join(" ");
			anyhow!("config errs: {errs}")
		})
}

/// Sets `ValidatorCount` in staking pallet to `validator_count`.
pub async fn set_validator_count(
	ah_client: &OnlineClient<PolkadotConfig>,
	validator_count: u32,
) -> Result<(), anyhow::Error> {
	let set_validator_count = dynamic::tx("Staking", "set_validator_count", vec![validator_count]);
	let sudo = dynamic::tx("Sudo", "sudo", vec![set_validator_count.into_value()]);
	let alice = dev::alice();

	ah_client
		.tx()
		.sign_and_submit_then_watch_default(&sudo, &alice)
		.await?
		.wait_for_finalized_success()
		.await?;
	Ok(())
}

/// Sets `Mode` in `StakingNextAhClient` pallet to `Active`.
pub async fn activate_ah_client(
	rc_client: &OnlineClient<PolkadotConfig>,
) -> Result<(), anyhow::Error> {
	let mode_value = Value::variant("Active", Composite::unnamed(vec![]));
	let set_validator_count = dynamic::tx("StakingNextAhClient", "set_mode", vec![mode_value]);
	let sudo = dynamic::tx("Sudo", "sudo", vec![set_validator_count.into_value()]);
	let alice = dev::alice();

	rc_client
		.tx()
		.sign_and_submit_then_watch_default(&sudo, &alice)
		.await?
		.wait_for_finalized_success()
		.await?;
	Ok(())
}
