// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

use subxt::{
	ext::scale_value::{Composite, ValueDef},
	OnlineClient, PolkadotConfig,
};

use crate::staking_next::{activate_ah_client, build_network_config, set_validator_count};

// Events generated by rc_client. Event here doesn't necessary mean 'event in the substrate
// context'. It can be anything representing a point of interest for the tests.
enum RcClientEvent {
	SessionReportReceived { activation_time_stamp: Option<u128> },
	PagedElectionProceeded { page_idx: u128, page_content: Result<u128, ()> },
}

// Events generated by ah_client. See [`RcEvents`] for what an event means in this context.
enum AhClientEvent {
	NewValidatorSetCount(u128),
}

enum TestState {
	// When AH is spawned and AhClient is activated on RC at least a single session change should
	// happen before an election is triggered.
	WaitingForInitialSessionChange,
	// Wait for an election to complete. We get into this state after the first session change and
	// move on when we receive a page containing `Ok(0)` as a result.
	WaitingForElectionResult,
	// The validator set should be delivered to RC
	WaitForNewValidatorSetCount,
	// AH should receive a session report with an activation timestamp
	WaitForSessionReportWithActivationTimestamp { elapsed_sessions: usize },
}

impl TestState {
	pub fn new() -> Self {
		Self::WaitingForInitialSessionChange
	}

	pub fn on_ah_client_event(&mut self, event: AhClientEvent) {
		match event {
			AhClientEvent::NewValidatorSetCount(new_validator_set_count) => {
				self.handle_new_validator_set_count(new_validator_set_count);
			},
		}
	}

	pub fn on_rc_client_event(
		&mut self,
		event: RcClientEvent,
		end_test: &mut Option<tokio::sync::oneshot::Sender<()>>,
	) {
		match event {
			RcClientEvent::SessionReportReceived { activation_time_stamp } => {
				self.handle_ah_session_report_received(activation_time_stamp, end_test);
			},
			RcClientEvent::PagedElectionProceeded { page_idx, page_content } => {
				self.handle_ah_paged_election_proceeded(page_idx, page_content);
			},
		}
	}

	fn handle_ah_session_report_received(
		&mut self,
		activation_time_stamp: Option<u128>,
		end_test: &mut Option<tokio::sync::oneshot::Sender<()>>,
	) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				log::info!("One session change after activating AH client");
				*self = TestState::WaitingForElectionResult;
			},
			TestState::WaitingForElectionResult => {
				// ignore
			},
			TestState::WaitForNewValidatorSetCount => {
				// ignore
			},
			TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions } => {
				if activation_time_stamp.is_some() {
					log::info!(
						"Got session report with activation timestamp: {:?}",
						activation_time_stamp
					);
					// All done. Terminate the test.
					end_test.take().unwrap().send(()).unwrap();
					return
				}
				*elapsed_sessions += 1;

				if *elapsed_sessions > 6 {
					assert!(
						activation_time_stamp.is_some(),
						"Expected activation time stamp within 6 sessions"
					);
				}
			},
		}
	}

	fn handle_ah_paged_election_proceeded(
		&mut self,
		page_idx: u128,
		page_content: Result<u128, ()>,
	) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				assert!(false, "PagedElectionProceeded before the first session change?");
			},
			TestState::WaitingForElectionResult => {
				log::info!(
					"Paged election proceeded: page_idx: {}, page_content: {:?}",
					page_idx,
					page_content
				);

				// we can be smarter here and avoid the magic numbers
				if page_idx == 7 {
					assert!(page_content.is_ok(), "Expected Ok");
					assert!(page_content.unwrap() == 500, "Expected 500");
				} else if page_idx == 6 {
					assert!(page_content.is_ok(), "Expected Ok");
					assert!(page_content.unwrap() == 0, "Expected 0");

					// at this point it's safe to assume that the election is complete
					// we will get more `PagedElectionProceeded` with `Err` but we'll just ignore
					// them
					*self = TestState::WaitForNewValidatorSetCount;
					log::info!("Election complete, waiting for validator set on RC");
				} else {
					assert!(page_content.is_err(), "Expected Err for page {}", page_idx);
				}
			},
			TestState::WaitForNewValidatorSetCount => {
				// as per the comment above - ignore these
			},
			TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions: _ } => {
				// ignore
			},
		}
	}

	fn handle_new_validator_set_count(&mut self, new_validator_set_count: u128) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				assert!(false, "New validator set count before the first session change?");
			},
			TestState::WaitingForElectionResult => {
				assert!(false, "New validator set count before the election is complete?");
			},
			TestState::WaitForNewValidatorSetCount => {
				assert!(new_validator_set_count == 500, "Expected a validator set count of 500");
				log::info!("Got NewValidatorSetCount on RC");
				*self =
					TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions: 0 };
			},
			TestState::WaitForSessionReportWithActivationTimestamp { elapsed_sessions: _ } => {
				// ignore
			},
		}
	}
}

/// This test is intended for local runs only because it requires manual steps and takes quite a lot
/// of time to execute.
#[tokio::test(flavor = "multi_thread")]
async fn happy_case() -> Result<(), anyhow::Error> {
	let _ = env_logger::try_init_from_env(
		env_logger::Env::default().filter_or(env_logger::DEFAULT_FILTER_ENV, "info"),
	);

	let config = build_network_config().await?;

	let spawn_fn = zombienet_sdk::environment::get_spawn_fn();
	let network = spawn_fn(config).await?;

	log::info!("Spawned");

	let rc_node = network.get_node("alice")?;
	let ah_next_node = network.get_node("charlie")?;

	let rc_client: OnlineClient<PolkadotConfig> = rc_node.wait_client().await?;
	let ah_next_client: OnlineClient<PolkadotConfig> = ah_next_node.wait_client().await?;

	let mut test_state = TestState::new();

	log::info!("Set validator count to 500");
	set_validator_count(&ah_next_client, 500).await?;

	log::info!("Activate AH Client");
	activate_ah_client(&rc_client).await?;

	let mut rc_blocks_sub = rc_client.blocks().subscribe_finalized().await?;
	let mut ah_blocks_sub = ah_next_client.blocks().subscribe_finalized().await?;
	let (tx, rx) = tokio::sync::oneshot::channel::<()>();
	let mut rx = rx;
	let mut tx = Some(tx);

	loop {
		tokio::select! {
			rc_block = rc_blocks_sub.next() => {
				if let Some(block) = rc_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;
						if event.pallet_name() == "StakingNextAhClient" {
							match event.variant_name() {
								"ValidatorSetReceived" => {
									let ev = parse_new_validator_set_count(event.field_values()?).expect("ValidatorSetReceived event should be parsed");
									test_state.on_ah_client_event(ev);
								},
								_ => {
									log::debug!(
										"ON RC: block: {}; pallet: StakingNextAhClient;  Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						}
					}
				}
			}
			ah_block = ah_blocks_sub.next() => {
				if let Some(block) = ah_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;

						if event.pallet_name() == "StakingNextRcClient" {
							match event.variant_name() {
								"SessionReportReceived" => {
									let fields = event.field_values()?;
									let ev = parse_session_report_received(fields).expect("SessionReportReceived event should be parsed");
									test_state.on_rc_client_event(ev, &mut tx);
								},
								_ => {
									log::debug!(
										"ON AH: block: {} StakingNextRcClient Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}

						} else if event.pallet_name() == "Staking" {
							match event.variant_name() {
								"PagedElectionProceeded" => {
									log::debug!(
										"ON AH: block: {} Staking PagedElectionProceeded Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
									let ev = parse_paged_election_proceeded(event.field_values()?).expect("PagedElectionProceeded event should be parsed");
									test_state.on_rc_client_event(ev, &mut tx);
								},
								_ => {
									log::debug!(
										"ON AH: block: {} Staking Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						} else if event.pallet_name() == "StakingNextAhClient" {
							assert!(false, "StakingNextAhClient event on AH client");
						}
						else {
							log::debug!("block: {} Event for pallet: {:?}; variant: {:?}; fields: {:?}", block.number(), event.pallet_name(), event.variant_name(), event.field_values()?);
						}
					}
				}
			}
			_ = &mut rx => {
				log::info!("Test finished");
				break
			}
		}
	}

	Ok(())
}

// TODO: There should be a better way to do this.
fn parse_paged_election_proceeded(fields: Composite<u32>) -> Option<RcClientEvent> {
	if let subxt::ext::scale_value::Composite::Named(fields) = fields {
		assert!(fields.len() == 2, "Expected 2 fields");
		assert!(fields[0].0 == "page", "Expected page");

		let page_idx = fields[0].1.as_u128().unwrap();

		if let ValueDef::Variant(result) = &fields[1].1.value {
			if result.name == "Err" {
				return Some(RcClientEvent::PagedElectionProceeded {
					page_idx,
					page_content: Err(()),
				})
			}

			assert!(result.name == "Ok", "Expected Ok");

			if let subxt::ext::scale_value::Composite::Unnamed(r) = &result.values {
				return Some(RcClientEvent::PagedElectionProceeded {
					page_idx,
					page_content: Ok(r[0].as_u128().unwrap()),
				})
			} else {
				assert!(false, "Expected unnamed composite");
			}
		} else {
			assert!(false, "Expected variant");
		}
	} else {
		assert!(false, "Expected named composite");
	}

	None
}

fn parse_new_validator_set_count(fields: Composite<u32>) -> Option<AhClientEvent> {
	if let subxt::ext::scale_value::Composite::Named(fields) = fields {
		assert!(fields.len() == 4, "Expected 4 fields");

		// we are interested only in `new_validator_set_count`

		assert!(fields[1].0 == "new_validator_set_count", "Expected new_validator_set_count");

		let new_validator_set_count = fields[1].1.as_u128().unwrap();

		return Some(AhClientEvent::NewValidatorSetCount(new_validator_set_count))
	}

	None
}

fn parse_session_report_received(fields: Composite<u32>) -> Option<RcClientEvent> {
	if let subxt::ext::scale_value::Composite::Named(fields) = fields {
		assert!(fields.len() == 4, "Expected 4 fields");
		assert!(fields[1].0 == "activation_timestamp", "Expected activation_timestamp");

		if let ValueDef::Variant(activation_timestamp_variant) = &fields[1].1.value {
			if activation_timestamp_variant.name == "None" {
				return Some(RcClientEvent::SessionReportReceived { activation_time_stamp: None })
			}

			assert!(activation_timestamp_variant.name == "Some", "Expected Some");

			if let subxt::ext::scale_value::Composite::Unnamed(act) =
				&activation_timestamp_variant.values
			{
				if let ValueDef::Composite(a) = &act[0].value {
					if let subxt::ext::scale_value::Composite::Unnamed(a) = &a {
						return Some(RcClientEvent::SessionReportReceived {
							activation_time_stamp: Some(a[0].as_u128().unwrap()),
						})
					} else {
						log::info!("act: {:?}", act);
						assert!(false, "Expected ValueDef::Primitive`(");
					}
				} else {
					log::info!("act: {:?}", act);
					assert!(false, "Expected ValueDef::Composite(");
				}
			} else {
				assert!(false, "Expected unnamed composite");
			}
		} else {
			assert!(false, "Expected variant");
		}
	} else {
		assert!(false, "Expected named composite");
	}

	None
}
