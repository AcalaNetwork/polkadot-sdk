// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

use subxt::{
	ext::scale_value::{Composite, ValueDef},
	OnlineClient, PolkadotConfig,
};

use crate::staking_next::{activate_ah_client, build_network_config, set_validator_count};

// Events generated by rc_client. Event here doesn't necessary mean 'event in the substrate
// context'. It can be anything representing a point of interest for the tests.
enum RcClientEvent {
	SessionReportReceived,
	PagedElectionProceeded { page_idx: u128, page_content: Result<u128, ()> },
}

// Events generated by ah_client. See [`RcEvents`] for what an event means in this context.
enum AhClientEvent {}

enum TestState {
	// When AH is spawned and AhClient is activated on RC at least a single session change should
	// happen before an election is triggered.
	WaitingForInitialSessionChange,
	// Wait for an election to complete. We get into this state after the first session change and
	// move on when we receive the last page from the election process.
	WaitingForElection,
	// The validator set should be delivered to RC
	WaitForValidatorSetOnRc,
}

impl TestState {
	pub fn new() -> Self {
		Self::WaitingForInitialSessionChange
	}

	pub fn on_rc_client_event(&mut self, event: RcClientEvent) {
		match event {
			RcClientEvent::SessionReportReceived => {
				self.handle_ah_session_report_received();
			},
			RcClientEvent::PagedElectionProceeded { page_idx, page_content } => {
				self.handle_ah_paged_election_proceeded(page_idx, page_content);
			},
		}
	}

	fn handle_ah_session_report_received(&mut self) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				log::info!("One session change after activating AH client");
				*self = TestState::WaitingForElection;
			},
			TestState::WaitingForElection => {
				// these should be ignored
			},
			TestState::WaitForValidatorSetOnRc => {
				// these should be ignored
			},
		}
	}

	fn handle_ah_paged_election_proceeded(
		&mut self,
		page_idx: u128,
		page_content: Result<u128, ()>,
	) {
		match self {
			TestState::WaitingForInitialSessionChange => {
				assert!(false, "PagedElectionProceeded before the first session change?");
			},
			TestState::WaitingForElection => {
				log::info!(
					"Paged election proceeded: page_idx: {}, page_content: {:?}",
					page_idx,
					page_content
				);

				// we can be smarter here
				if page_idx == 7 {
					assert!(page_content.is_ok(), "Expected Ok");
					assert!(page_content.unwrap() == 500, "Expected 500");
				} else if page_idx == 6 {
					assert!(page_content.is_ok(), "Expected Ok");
					assert!(page_content.unwrap() == 0, "Expected 0");
				} else {
					assert!(page_content.is_err(), "Expected Err for page {}", page_idx);
				}

				if page_idx == 0 {
					// election is complete, move on
					*self = TestState::WaitForValidatorSetOnRc;
					log::info!("Election complete, waiting for validator set on RC");
				}
			},
			TestState::WaitForValidatorSetOnRc => {
				// We should stop the test before the second election
				assert!(false, "Second election has started.");
			},
		}
	}
}

#[tokio::test(flavor = "multi_thread")]
async fn happy_case() -> Result<(), anyhow::Error> {
	let _ = env_logger::try_init_from_env(
		env_logger::Env::default().filter_or(env_logger::DEFAULT_FILTER_ENV, "info"),
	);

	let config = build_network_config().await?;

	let spawn_fn = zombienet_sdk::environment::get_spawn_fn();
	let network = spawn_fn(config).await?;

	log::info!("Spawned");

	let rc_node = network.get_node("alice")?;
	let ah_next_node = network.get_node("charlie")?;

	let rc_client: OnlineClient<PolkadotConfig> = rc_node.wait_client().await?;
	let ah_next_client: OnlineClient<PolkadotConfig> = ah_next_node.wait_client().await?;

	let mut test_state = TestState::new();

	log::info!("Set validator count to 500");
	set_validator_count(&ah_next_client, 500).await?;

	log::info!("Activate AH Client");
	activate_ah_client(&rc_client).await?;

	let mut rc_blocks_sub = rc_client.blocks().subscribe_finalized().await?;
	let mut ah_blocks_sub = ah_next_client.blocks().subscribe_finalized().await?;

	loop {
		tokio::select! {
			rc_block = rc_blocks_sub.next() => {
				if let Some(block) = rc_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;
						if event.pallet_name() == "StakingNextAhClient" {
							log::info!(
								"ON RC: block: {}; pallet: {:?};  Event: {:?}; Fields: {:?}",
								block.number(),
								event.pallet_name(),
								event.variant_name(),
								event.field_values()?
							);


						}
					}
				}
			}
			ah_block = ah_blocks_sub.next() => {
				if let Some(block) = ah_block {
					let block = block?;
					for event in block.events().await?.iter() {
						let event = event?;

						if event.pallet_name() == "StakingNextRcClient" {
							match event.variant_name() {
								"SessionReportReceived" => {
									test_state.on_rc_client_event(RcClientEvent::SessionReportReceived);
								},
								_ => {
									log::info!(
										"ON AH: block: {} StakingNextRcClient Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}

						} else if event.pallet_name() == "Staking" {
							match event.variant_name() {
								"PagedElectionProceeded" => {
									log::info!(
										"ON AH: block: {} Staking PagedElectionProceeded Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
									let ev = parse_paged_election_proceeded(event.field_values()?).expect("PagedElectionProceeded event should be parsed");
									test_state.on_rc_client_event(ev);
								},
								_ => {
									log::info!(
										"ON AH: block: {} Staking Event: {:?}; Fields: {:?}",
										block.number(),
										event.variant_name(),
										event.field_values()?
									);
								}
							}
						} else if event.pallet_name() == "StakingNextAhClient" {
							assert!(false, "StakingNextAhClient event on AH client");
						}
						else {
							log::debug!("block: {} Event for pallet: {:?}; variant: {:?}; fields: {:?}", block.number(), event.pallet_name(), event.variant_name(), event.field_values()?);
						}
					}
				}
			}
		}
	}
}

// TODO: There should be a better way to do this.
fn parse_paged_election_proceeded(fields: Composite<u32>) -> Option<RcClientEvent> {
	if let subxt::ext::scale_value::Composite::Named(fields) = fields {
		assert!(fields.len() == 2, "Expected 2 fields");
		assert!(fields[0].0 == "page", "Expected page");

		let page_idx = fields[0].1.as_u128().unwrap();

		if let ValueDef::Variant(result) = &fields[1].1.value {
			if result.name == "Err" {
				return Some(RcClientEvent::PagedElectionProceeded {
					page_idx,
					page_content: Err(()),
				})
			}

			assert!(result.name == "Ok", "Expected Ok");

			if let subxt::ext::scale_value::Composite::Unnamed(r) = &result.values {
				return Some(RcClientEvent::PagedElectionProceeded {
					page_idx,
					page_content: Ok(r[0].as_u128().unwrap()),
				})
			} else {
				assert!(false, "Expected unnamed composite");
			}
		} else {
			assert!(false, "Expected variant");
		}
	} else {
		assert!(false, "Expected named composite");
	}

	None
}
