From 8491a434375a9634bb2c903d7da5f761cab40b20 Mon Sep 17 00:00:00 2001
From: Paolo La Camera <paolo@parity.io>
Date: Thu, 26 Jun 2025 11:44:56 +0000
Subject: [PATCH 2/5] fast-unstake: Switch Staking to async in pallet tests

With the migration to staking-async, some functional changes are needed
in the tests:
- Validator Nominations: Updated all nomination calls to
use valid validators (`VALIDATOR_PREFIX`) instead of self-nomination or
invalid targets
- Genesis Setup: Fixed the genesis configuration to
properly set up validators and nominators with valid targets
- Exposure Creation: Updated `create_exposed_nominator` to use the correct
staking-async API
---
 Cargo.lock                                |  4 +-
 substrate/frame/fast-unstake/Cargo.toml   | 14 +++-
 substrate/frame/fast-unstake/src/mock.rs  | 92 ++++++++++++++++-------
 substrate/frame/fast-unstake/src/tests.rs | 10 +--
 4 files changed, 79 insertions(+), 41 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 1bb1c9b523..734d1c062e 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -12366,13 +12366,15 @@ dependencies = [
  "frame-system",
  "log",
  "pallet-balances",
- "pallet-staking",
+ "pallet-staking-async",
+ "pallet-staking-async-rc-client",
  "pallet-staking-reward-curve",
  "pallet-timestamp",
  "parity-scale-codec",
  "scale-info",
  "sp-core 28.0.0",
  "sp-io 30.0.0",
+ "sp-npos-elections",
  "sp-runtime 31.0.1",
  "sp-staking",
  "sp-tracing 16.0.0",
diff --git a/substrate/frame/fast-unstake/Cargo.toml b/substrate/frame/fast-unstake/Cargo.toml
index 209406dc3f..724ddded15 100644
--- a/substrate/frame/fast-unstake/Cargo.toml
+++ b/substrate/frame/fast-unstake/Cargo.toml
@@ -33,10 +33,12 @@ docify = { workspace = true }
 
 [dev-dependencies]
 pallet-balances = { workspace = true, default-features = true }
-pallet-staking = { workspace = true, default-features = true }
+pallet-staking-async = { workspace = true, default-features = true }
+pallet-staking-async-rc-client = { workspace = true, default-features = true }
 pallet-staking-reward-curve = { workspace = true, default-features = true }
 pallet-timestamp = { workspace = true, default-features = true }
 sp-core = { workspace = true }
+sp-npos-elections = { workspace = true, default-features = true }
 sp-tracing = { workspace = true, default-features = true }
 
 [features]
@@ -49,9 +51,11 @@ std = [
 	"frame-system/std",
 	"log/std",
 	"pallet-balances/std",
-	"pallet-staking/std",
+	"pallet-staking-async/std",
+	"pallet-staking-async-rc-client/std",
 	"pallet-timestamp/std",
 	"scale-info/std",
+	"sp-npos-elections/std",
 	"sp-core/std",
 	"sp-io/std",
 	"sp-runtime/std",
@@ -64,7 +68,8 @@ runtime-benchmarks = [
 	"frame-support/runtime-benchmarks",
 	"frame-system/runtime-benchmarks",
 	"pallet-balances/runtime-benchmarks",
-	"pallet-staking/runtime-benchmarks",
+	"pallet-staking-async/runtime-benchmarks",
+	"pallet-staking-async-rc-client/runtime-benchmarks",
 	"pallet-timestamp/runtime-benchmarks",
 	"sp-runtime/runtime-benchmarks",
 	"sp-staking/runtime-benchmarks",
@@ -74,7 +79,8 @@ try-runtime = [
 	"frame-support/try-runtime",
 	"frame-system/try-runtime",
 	"pallet-balances/try-runtime",
-	"pallet-staking/try-runtime",
+	"pallet-staking-async/try-runtime",
+	"pallet-staking-async-rc-client/try-runtime",
 	"pallet-timestamp/try-runtime",
 	"sp-runtime/try-runtime",
 ]
diff --git a/substrate/frame/fast-unstake/src/mock.rs b/substrate/frame/fast-unstake/src/mock.rs
index a89633e18b..85d84ac2ee 100644
--- a/substrate/frame/fast-unstake/src/mock.rs
+++ b/substrate/frame/fast-unstake/src/mock.rs
@@ -21,12 +21,17 @@ use frame_support::{
 	assert_ok, derive_impl,
 	pallet_prelude::*,
 	parameter_types,
-	traits::{ConstU64, Currency},
+	traits::{ConstU32, ConstU64, Currency},
 	weights::constants::WEIGHT_REF_TIME_PER_SECOND,
 };
+use frame_system::EnsureRoot;
+use pallet_staking_async::{
+	session_rotation::Eras, Exposure, IndividualExposure, StakerStatus,
+	UseNominatorsAndValidatorsMap, UseValidatorsMap,
+};
+use pallet_staking_async_rc_client as rc_client;
 use sp_runtime::{traits::IdentityLookup, BuildStorage};
-
-use pallet_staking::{Exposure, IndividualExposure, StakerStatus};
+use sp_staking::currency_to_vote::SaturatingCurrencyToVote;
 
 pub type AccountId = u128;
 pub type BlockNumber = u64;
@@ -119,18 +124,42 @@ impl frame_election_provider_support::ElectionProvider for MockElection {
 	}
 }
 
-#[derive_impl(pallet_staking::config_preludes::TestDefaultConfig)]
-impl pallet_staking::Config for Runtime {
+// Mock era payout
+pub struct MockEraPayout;
+impl pallet_staking_async::EraPayout<Balance> for MockEraPayout {
+	fn era_payout(
+		_total_staked: Balance,
+		_total_issuance: Balance,
+		_era_duration_millis: u64,
+	) -> (Balance, Balance) {
+		(1000, 100)
+	}
+}
+
+// Mock RC client interface
+pub struct MockRcClient;
+impl rc_client::RcClientInterface for MockRcClient {
+	type AccountId = AccountId;
+	fn validator_set(
+		_new_validator_set: Vec<Self::AccountId>,
+		_id: u32,
+		_prune_up_to: Option<u32>,
+	) {
+	}
+}
+
+#[derive_impl(pallet_staking_async::config_preludes::TestDefaultConfig)]
+impl pallet_staking_async::Config for Runtime {
 	type OldCurrency = Balances;
 	type Currency = Balances;
-	type UnixTime = pallet_timestamp::Pallet<Self>;
-	type AdminOrigin = frame_system::EnsureRoot<Self::AccountId>;
-	type BondingDuration = BondingDuration;
-	type EraPayout = pallet_staking::ConvertCurve<RewardCurve>;
+	type AdminOrigin = EnsureRoot<Self::AccountId>;
 	type ElectionProvider = MockElection;
-	type GenesisElectionProvider = Self::ElectionProvider;
-	type VoterList = pallet_staking::UseNominatorsAndValidatorsMap<Self>;
-	type TargetList = pallet_staking::UseValidatorsMap<Self>;
+	type VoterList = UseNominatorsAndValidatorsMap<Self>;
+	type TargetList = UseValidatorsMap<Self>;
+	type CurrencyToVote = SaturatingCurrencyToVote;
+	type EraPayout = MockEraPayout;
+	type RcClientInterface = MockRcClient;
+	type WeightInfo = ();
 }
 
 parameter_types! {
@@ -156,7 +185,7 @@ frame_support::construct_runtime!(
 		System: frame_system,
 		Timestamp: pallet_timestamp,
 		Balances: pallet_balances,
-		Staking: pallet_staking,
+		Staking: pallet_staking_async,
 		FastUnstake: fast_unstake,
 	}
 );
@@ -216,7 +245,7 @@ impl ExtBuilder {
 				(v, Exposure { total: 0, own: 0, others })
 			})
 			.for_each(|(validator, exposure)| {
-				pallet_staking::EraInfo::<T>::set_exposure(era, &validator, exposure);
+				Eras::<T>::upsert_exposure(era, &validator, exposure);
 			});
 	}
 
@@ -248,13 +277,18 @@ impl ExtBuilder {
 		}
 		.assimilate_storage(&mut storage);
 
-		let _ = pallet_staking::GenesisConfig::<Runtime> {
+		let _ = pallet_staking_async::GenesisConfig::<Runtime> {
 			stakers: self
 				.unexposed
 				.into_iter()
-				.map(|(x, y, z)| (x, y, z, pallet_staking::StakerStatus::Nominator(vec![42])))
-				.chain(validators_range.map(|x| (x, x, 100, StakerStatus::Validator)))
-				.chain(nominators_range.map(|x| (x, x, 100, StakerStatus::Nominator(vec![x]))))
+				.map(|(x, _y, z)| {
+					(x, z, pallet_staking_async::StakerStatus::Nominator(vec![VALIDATOR_PREFIX]))
+				})
+				.chain(validators_range.map(|x| (x, 100, StakerStatus::Validator)))
+				.chain(
+					nominators_range
+						.map(|x| (x, 100, StakerStatus::Nominator(vec![VALIDATOR_PREFIX]))),
+				)
 				.collect::<Vec<_>>(),
 			..Default::default()
 		}
@@ -271,7 +305,7 @@ impl ExtBuilder {
 			}
 
 			// because we read this value as a measure of how many validators we have.
-			pallet_staking::ValidatorCount::<Runtime>::put(VALIDATORS_PER_ERA as u32);
+			pallet_staking_async::ValidatorCount::<Runtime>::put(VALIDATORS_PER_ERA as u32);
 		});
 
 		ext
@@ -306,32 +340,32 @@ pub(crate) fn next_block(on_idle: bool) {
 }
 
 pub fn assert_unstaked(stash: &AccountId) {
-	assert!(!pallet_staking::Bonded::<T>::contains_key(stash));
-	assert!(!pallet_staking::Payee::<T>::contains_key(stash));
-	assert!(!pallet_staking::Validators::<T>::contains_key(stash));
-	assert!(!pallet_staking::Nominators::<T>::contains_key(stash));
+	assert!(!pallet_staking_async::Bonded::<T>::contains_key(stash));
+	assert!(!pallet_staking_async::Payee::<T>::contains_key(stash));
+	assert!(!pallet_staking_async::Validators::<T>::contains_key(stash));
+	assert!(!pallet_staking_async::Nominators::<T>::contains_key(stash));
 }
 
 pub fn create_exposed_nominator(exposed: AccountId, era: u32) {
 	// create an exposed nominator in passed era
-	let mut exposure = pallet_staking::EraInfo::<T>::get_full_exposure(era, &VALIDATORS_PER_ERA);
+	let mut exposure = Staking::eras_stakers(era, &VALIDATOR_PREFIX);
 	exposure.others.push(IndividualExposure { who: exposed, value: 0 as Balance });
-	pallet_staking::EraInfo::<T>::set_exposure(era, &VALIDATORS_PER_ERA, exposure);
+	Eras::<T>::upsert_exposure(era, &VALIDATOR_PREFIX, exposure);
 
 	Balances::make_free_balance_be(&exposed, 100);
 	assert_ok!(Staking::bond(
 		RuntimeOrigin::signed(exposed),
 		10,
-		pallet_staking::RewardDestination::Staked
+		pallet_staking_async::RewardDestination::Staked
 	));
-	assert_ok!(Staking::nominate(RuntimeOrigin::signed(exposed), vec![exposed]));
+	assert_ok!(Staking::nominate(RuntimeOrigin::signed(exposed), vec![VALIDATOR_PREFIX]));
 	// register the exposed one.
 	assert_ok!(FastUnstake::register_fast_unstake(RuntimeOrigin::signed(exposed)));
 }
 
 pub fn set_active_era(era: sp_staking::EraIndex) {
-	pallet_staking::CurrentEra::<T>::put(era);
-	pallet_staking::ActiveEra::<T>::put(pallet_staking::ActiveEraInfo {
+	pallet_staking_async::CurrentEra::<T>::put(era);
+	pallet_staking_async::ActiveEra::<T>::put(pallet_staking_async::ActiveEraInfo {
 		index: era,
 		start: Some(0),
 	});
diff --git a/substrate/frame/fast-unstake/src/tests.rs b/substrate/frame/fast-unstake/src/tests.rs
index 1b3a581689..9baa48c511 100644
--- a/substrate/frame/fast-unstake/src/tests.rs
+++ b/substrate/frame/fast-unstake/src/tests.rs
@@ -28,7 +28,7 @@ use frame_support::{
 		Currency,
 	},
 };
-use pallet_staking::{CurrentEra, RewardDestination};
+use pallet_staking_async::{CurrentEra, RewardDestination};
 
 use sp_runtime::traits::BadOrigin;
 use sp_staking::StakingInterface;
@@ -806,12 +806,8 @@ mod on_idle {
 			assert_ok!(FastUnstake::register_fast_unstake(RuntimeOrigin::signed(VALIDATOR_PREFIX)));
 
 			// but they indeed are exposed!
-			assert!(pallet_staking::EraInfo::<T>::get_paged_exposure(
-				BondingDuration::get() - 1,
-				&VALIDATOR_PREFIX,
-				0
-			)
-			.is_some());
+			let exposure = Staking::eras_stakers(BondingDuration::get() - 1, &VALIDATOR_PREFIX);
+			assert!(exposure.total > 0 || !exposure.others.is_empty());
 
 			// process a block, this validator is exposed and has been slashed.
 			next_block(true);
-- 
2.50.0

